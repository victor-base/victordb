#include <victor/victor.h>
#include <limits.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include "fileutils.h"
#include "viproto.h"
#include "socket.h"
#include "buffer.h"
#include "server.h"
#include "index_server.h"
#include "log.h"

/**
 * @brief Handles a delete (vector and value removal) message.
 *
 * This function processes an incoming `MSG_DELETE` message, parses the ID of the item
 * to delete, an        }
        if (core->op_add_counter + core->op_del_counter > get_export_threshold()) {
            int ret;
            log_message(LOG_INFO, "Exporting index to disk (operations: %d)", 
                       core->op_add_counter + core->op_del_counter);empts to remove both the vector from the index and the value 
 * from the key-value store.
 *
 * Workflow:
 * 1. Parse the message with `buffer_read_delete()` to extract the ID.
 * 2. Attempt to delete the vector using `delete()` and the associated value using `kv_del()`.
 * 3. If either operation fails, log the error and respond with an error message.
 * 4. If both operations succeed, increment the delete operation counter and return success.
 *
 * @param core Pointer to the VictorIndex database context.
 * @param msg  Pointer to the input/output message buffer.
 *
 * @return 0 on success, -1 on failure, or error code response written into the message buffer.
 *
 * @warning If only one of the operations (vector or value deletion) fails, the system logs
 *          the issue but does not attempt to rollback the other deletion.
 */
static int handle_delete_message(VictorIndex *core, buffer_t *msg, FILE *wal) {
    uint64_t id;
    int ret, vret;

    ret = buffer_read_delete(msg, &id);
    if (ret == -1) {
        log_message(LOG_ERROR, "parsing del message");
        return -1;
    }
        
    if ((vret = delete(core->index, id)) != SUCCESS) {
        log_message(LOG_ERROR, 
            "unable to delete (%llu) - index: %s",
            (unsigned long long)id, index_strerror(vret)
        );
    } else {
        core->op_del_counter++;
        if (wal && buffer_dump_wal(msg, wal) != 0)
            log_message(LOG_WARNING,
                "writing wal (%d) - message: %s",
                errno, strerror(errno)
            );
    }
    return buffer_write_op_result(msg, MSG_OP_RESULT, vret, index_strerror(vret));
}

/**
 * @brief Handles an add (vector insert) message.
 *
 * This function processes an incoming `MSG_INSERT` message, extracts the vector and 
 * associated value, assigns a new unique ID, inserts the vector into the index, 
 * and stores the value in the key-value store.
 *
 * Workflow:
 * 1. Parse the message using `buffer_read_insert()` to extract the vector and value.
 * 2. Assign a unique ID and insert the vector into the vector index using `insert()`.
 * 3. If successful, store the value in the KV store with `kv_put()`.
 * 4. If KV storage fails, rollback the vector insert using `delete()`.
 * 5. On success, respond with the assigned ID via `buffer_write_add_result()`.
 * 6. On any failure, send an appropriate error response via `buffer_write_error()`.
 *
 * @param core Pointer to the VictorIndex database context.
 * @param msg  Pointer to the input/output message buffer.
 *
 * @return 0 on success, -1 on failure.
 *
 * @note The ID is generated by incrementing the database's internal `core->id` counter.
 *
 * @warning If insertion into the KV store fails after the vector was inserted, the vector 
 *          is rolled back and an error is returned.
 *
 * @warning The function performs dynamic memory allocations for vector and value, which
 *          are freed before return.
 */
static int handle_insert_message(VictorIndex *core, buffer_t *msg, FILE *wal) {
    float32_t *vector = NULL;
    uint64_t  id;
    size_t dims = 0;
    int code;
    int ret;

    ret = buffer_read_insert(msg, &id, &vector, &dims); 
    if (ret == -1) {
        log_message(LOG_ERROR, "parsing add message");
        return -1;
    }

    if ((code = insert(core->index, id, vector, dims)) != SUCCESS) {
        if (code == SYSTEM_ERROR)
            log_message(LOG_ERROR, 
                "at vector insert - code: %d - message: %s", 
                code, index_strerror(code)
            );
        else
            log_message(LOG_WARNING, 
                "at vector insert - code: %d - message: %s", 
                code, index_strerror(code)
            );
        goto cleanup;
    }

    if (wal && buffer_dump_wal(msg, wal) != 0)
        log_message(LOG_WARNING,
            "writing wal (%d) - message: %s",
            errno, strerror(errno)
        );

    core->op_add_counter++;
cleanup:
    if (vector) free(vector);
    return buffer_write_op_result(msg, MSG_OP_RESULT, code, index_strerror(code));
}

/**
 * @brief Handles a lookup (nearest neighbor search) message.
 *
 * This function processes an incoming `MSG_SEARCH` message, extracts the query vector,
 * performs a nearest neighbor search against the configured index, fetches the associated
 * values from the key-value store, and writes the results back to the buffer.
 *
 * Workflow:
 * 1. Parse the message and extract the query vector(s) via `buffer_read_search()`.
 * 2. Execute `search_n()` on the index with the specified number of matches.
 * 3. For each match, retrieve the corresponding value from the KV store.
 * 4. Write the lookup result back using `buffer_write_match_result()`.
 * 5. On any error, write an error message with `buffer_write_op_result()` and return -1.
 *
 * @param core Pointer to the database structure.
 * @param msg  Pointer to the input/output buffer containing the message.
 *
 * @return 0 on success, -1 on failure.
 *
 * @note If a matched key is not found in the KV store, a warning is logged but the 
 *       process continues with the rest of the results.
 *
 * @note The function dynamically allocates memory for the result array and
 *       associated values, which are freed before returning.
 *
 * @warning If memory allocation fails, the function sends a 500 error response
 *          to the client.
 */
static int handle_search_message(VictorIndex *core, buffer_t *msg) {
    uint64_t *ids    = NULL;
    float32_t *distances = NULL;

    MatchResult *result  = NULL;
    float32_t *vector    = NULL;
    
    size_t dims;
    int ret, n;

    ret = buffer_read_search(msg, &vector, &dims, &n);
    if (ret == -1) {
        log_message(LOG_ERROR, "parsing lookup message");
        return -1;
    }

    printf("N: %d -----------", n);

    result = calloc(n, sizeof(MatchResult));
    if (!result) {
        ret = buffer_write_op_result(msg, MSG_ERROR, 500, 
                                   "database out of memory");
        goto cleanup;
    }

    ret = search_n(core->index, vector, (uint16_t)dims, result, n);
    if (ret == SUCCESS) {
        int i = 0;
        if ((ids = calloc(n, sizeof(uint64_t))) == NULL || 
            (distances = calloc(n, sizeof(float32_t))) == NULL) { 
            ret = buffer_write_op_result(msg, MSG_ERROR, 500, 
                                       "database out of memory");
            goto cleanup;
        }
        
        while ( i < n ) {
            if (result[i].id == 0)
                break;
            ids[i] = result[i].id;
            distances[i] = result[i].distance;
            i++;
        }
        ret = buffer_write_match_result(msg, ids, distances, i);
    } else 
        ret = buffer_write_op_result(msg, MSG_ERROR, ret, index_strerror(ret));

cleanup:
    if (vector)    free(vector);
    if (result)    free(result);
    if (ids)       free(ids);
    if (distances) free(distances);
    return ret;
}


/**
 * @brief Loads and applies WAL operations to the VictorIndex database.
 *
 * This function reads and replays all operations stored in a Write-Ahead Log (WAL) file.
 * Each message is parsed and executed according to its type (e.g., `MSG_ADD`, `MSG_DEL`).
 * It ensures database state restoration after a crash or restart.
 *
 * @param core Pointer to the VictorIndex database structure to apply the WAL to.
 * @param wal  FILE* pointer to an already opened WAL file in binary read mode.
 *
 * @return 
 *   0 on successful import of all WAL entries,  
 *  -1 on failure due to I/O error or corrupted WAL content.
 *
 * @note 
 *   If the WAL contains unknown message types, they will be skipped with a warning.
 *   If an error occurs and `errno` is 0, it is assumed the WAL is corrupted.
 *   If `errno` is non-zero, a system-level I/O error is assumed.
 */
int victor_index_loadwal(VictorIndex *core, FILE *wal) {
    buffer_t *buff = alloc_buffer();
    int successful_entries = 0, failed_entries = 0;
    int ret;

    if (!buff) {
        log_message(LOG_ERROR, "failed to allocate buffer");
        return -1;
    }

    while ((ret = buffer_load_wal(buff, wal)) == 1) {
        switch (buff->hdr.type) {
            case MSG_INSERT:
                if (handle_insert_message(core, buff, NULL) != 0 || 
                    buff->hdr.type == MSG_ERROR)
                    failed_entries++;
                else
                    successful_entries++;

                break;
            case MSG_DELETE:
                if (handle_delete_message(core, buff, NULL) != 0 || 
                    buff->hdr.type == MSG_ERROR)
                    failed_entries++;
                else
                    successful_entries++;
                break;
            default:
                log_message(LOG_WARNING,
                    "unknown message type in WAL: %d", buff->hdr.type);
                break;
        }
    }

    free(buff);

    if (ret == 0) {
        if (failed_entries == 0) {
            log_message(LOG_INFO, 
                "Transaction log recovered: %d operations restored successfully", 
                successful_entries);
        } else {
            log_message(LOG_WARNING, 
                "Transaction log recovered: %d successful, %d failed operations", 
                successful_entries, failed_entries);
        }
        return 0;
    }

    if (errno == 0)
        log_message(LOG_ERROR, "Transaction log corrupted - data integrity compromised");
    else
        log_message(LOG_ERROR, "Transaction log read error: %s", strerror(errno));

    return -1;
}


/**
 * @brief Starts the VictorIndex server loop, handling client requests and writing to WAL.
 *
 * This function implements the main server loop for the VictorIndex database. It accepts
 * incoming UNIX domain socket connections, processes protocol messages from clients,
 * and writes changes to a Write-Ahead Log (WAL) file for durability.
 *
 * Supported message types:
 * - `MSG_INSERT`: Adds a new vector to the database and appends to the WAL.
 * - `MSG_DELETE`: Removes a vector and appends to the WAL.
 * - `MSG_SEARCH`: Performs a vector search (no WAL entry).
 *
 * The server uses `select()` to multiplex connections and listens until a termination
 * signal is received (`running == 0`), at which point it gracefully shuts down.
 *
 * @param core Pointer to the database structure.
 * @param server File descriptor of a bound and listening UNIX socket.
 *
 * @return 0 on clean shutdown, -1 on failure (e.g., memory, I/O, or socket error).
 *
 * @note The WAL file is opened in append mode. If it cannot be opened, the server
 *       fails to start. The server respects signals via the global `running` flag.
 *
 * @warning Only `MSG_INSERT` and `MSG_DELETE` are persisted in the WAL.
 * @warning Maximum number of simultaneous connections is limited by `MAX_CONNECTIONS`.
 * @warning If `recv_msg` or `send_msg` fail, the client connection is closed.
 */
int victor_index_server(VictorIndex *core, int server) {
    FILE *wal = NULL;
    int conn[MAX_CONNECTIONS];
    fd_set set, check;
    int max = server, n;
    buffer_t *buff = alloc_buffer();
    
    if (!buff) {
        log_message(LOG_ERROR, 
            "failed to allocate buffer"
        );
        close(server);
        return -1;
    }

    wal = fopen(IWAL_FILE, "ab");
    if (!wal) { 
        log_message(LOG_ERROR, 
            "failed to open WAL file '%s': %s", 
            IWAL_FILE, 
            strerror(errno)
        );
        free(buff);
        close(server);
        return -1;
    }
    for (int i=0; i < MAX_CONNECTIONS; i++) conn[i] = -1;

    FD_ZERO(&set);
    FD_ZERO(&check);
    FD_SET(server, &set);

    while (running) {
        memcpy(&check, &set, sizeof(fd_set));
        n = select(max+1, &check, NULL, NULL, NULL);
        if (n < 0 && (errno == EAGAIN || errno == EINTR))
            continue;
        else if (n < 0) {
            log_message(LOG_ERROR, 
                "fatal error on select (%d) - %s",
                errno, strerror(errno)
            );
            break;
        }
        if (FD_ISSET(server, &check)) {
            int i;
            int sd = unix_accept(server);
            if (sd == -1)
                if (errno != EAGAIN && errno != EINTR) {
                    log_message(LOG_ERROR, 
                        "fatal error on unix_accept (%d) - %s",
                        errno, strerror(errno)
                    );
                    break;
                }
            for (i = 0; i < MAX_CONNECTIONS; i++)
                if (conn[i] == -1) {
                    conn[i] = sd;
                    break;
                }
            if (i == MAX_CONNECTIONS) {
                log_message(LOG_WARNING,
                    "max connections reached - new client closed"
                );
                close(sd);
            } else {
                max = sd > max ? sd : max;
                FD_SET(sd, &set);
            }
            n--;
        }

        for (int i = 0; i < MAX_CONNECTIONS && n > 0; i++) {
            int ret = 0;
            if (FD_ISSET(conn[i], &check)) {
                n--;
                ret = recv_msg(conn[i], buff);
                if (ret == -1) {
                    log_message(LOG_WARNING,
                        "connection closed due to protocol or receive error"
                    );
                    FD_CLR(conn[i], &set);
                    close(conn[i]);
                    conn[i] = -1;
                    continue;
                }
                switch (buff->hdr.type) {
                case MSG_INSERT: 
                    ret = handle_insert_message(core, buff, wal);   
                    break;
                case MSG_DELETE:
                    ret = handle_delete_message(core, buff, wal);
                    break;
                case MSG_SEARCH:
                    ret = handle_search_message(core, buff);
                    break;
                default:
                    log_message(LOG_WARNING,
                        "invalid protocol message type: %d",
                        buff->hdr.type
                    );
                    ret = -1;
                }
                if (ret != -1) {
                    if (send_msg(conn[i], buff) == -1) {
                        FD_CLR(conn[i], &set);
                        close(conn[i]);
                        conn[i] = -1;
                    }
                } else {
                    FD_CLR(conn[i], &set);
                    close(conn[i]);
                    conn[i] = -1;
                }
            }
        }
        if (core->op_add_counter + core->op_del_counter > get_export_threshold()) {
            int ret;
            log_message(LOG_INFO, "Exporting index to disk (operations: %d)", 
                       core->op_add_counter + core->op_del_counter);
            if ((ret = export(core->index, INDEX_FILE)) != SUCCESS)
                log_message(LOG_WARNING, 
                    "Error during index export: %s", index_strerror(ret));
            else {
                log_message(LOG_INFO, "Index exported successfully, WAL file cleared");
                unlink(IWAL_FILE);
                core->op_add_counter = core->op_del_counter = 0;
            }
        }
    }
    log_message(LOG_INFO, "end main loop");
    fclose(wal);
    free(buff);
    for (int i = 0; i < MAX_CONNECTIONS; i ++)
        if (conn[i] != -1)
            close(conn[i]);
    close(server);
    return 0;
}