#include <victor/victor.h>
#include <victor/victorkv.h>
#include <limits.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include "fileutils.h"
#include "protocol.h"
#include "socket.h"
#include "buffer.h"
#include "server.h"
#include "log.h"


/**
 * @brief Global flag to control server loop execution.
 *
 * This volatile variable is modified asynchronously by signal handlers 
 * to indicate that the server should terminate gracefully.
 */
static volatile sig_atomic_t running = 1;

/**
 * @brief Signal handler to request server shutdown.
 *
 * Sets the global `running` flag to 0 when a termination signal (e.g., SIGINT, SIGTERM)
 * is received, causing the main server loop to exit cleanly.
 *
 * @param signo The signal number that was received.
 */
void handle_signal(int signo) {
    (void)signo;
    running = 0;
}


/**
 * @brief Handles a delete (vector and value removal) message.
 *
 * This function processes an incoming `MSG_DEL` message, parses the ID of the item
 * to delete, and attempts to remove both the vector from the index and the value 
 * from the key-value store.
 *
 * Workflow:
 * 1. Parse the message with `buffer_read_del()` to extract the ID.
 * 2. Attempt to delete the vector using `delete()` and the associated value using `kv_del()`.
 * 3. If either operation fails, log the error and respond with an error message.
 * 4. If both operations succeed, increment the delete operation counter and return success.
 *
 * @param core Pointer to the IndexKV database context.
 * @param msg  Pointer to the input/output message buffer.
 *
 * @return 0 on success, -1 on failure, or error code response written into the message buffer.
 *
 * @warning If only one of the operations (vector or value deletion) fails, the system logs
 *          the issue but does not attempt to rollback the other deletion.
 */
static int handle_del_message(IndexKV *core, buffer_t *msg) {
    uint64_t id;
    int ret, vret, kret = 0;

    ret = buffer_read_del(msg, &id);
    if (ret == -1) {
        log_message(LOG_ERROR, "parsing del message");
        return -1;
    }
        
    if ((vret = delete(core->index, id)) != SUCCESS ||
        (kret = kv_del(core->table, &id, 8)) != KV_SUCCESS) {
            log_message(LOG_ERROR, 
                "unable to delete (%llu) - index: %s, table: %s",
                (unsigned long long)id, index_strerror(vret), table_strerror(kret)
            );
        ret = buffer_write_error(msg, 
            vret != SUCCESS ? vret : kret, 
            vret != SUCCESS ? index_strerror(vret) : table_strerror(kret));
    } else {
        core->op_del_counter++;
        ret = buffer_write_del_result(msg, true);
    }
    return ret;
}

/**
 * @brief Handles an add (vector insert) message.
 *
 * This function processes an incoming `MSG_ADD` message, extracts the vector and 
 * associated value, assigns a new unique ID, inserts the vector into the index, 
 * and stores the value in the key-value store.
 *
 * Workflow:
 * 1. Parse the message using `buffer_read_add()` to extract the vector and value.
 * 2. Assign a unique ID and insert the vector into the vector index using `insert()`.
 * 3. If successful, store the value in the KV store with `kv_put()`.
 * 4. If KV storage fails, rollback the vector insert using `delete()`.
 * 5. On success, respond with the assigned ID via `buffer_write_add_result()`.
 * 6. On any failure, send an appropriate error response via `buffer_write_error()`.
 *
 * @param core Pointer to the IndexKV database context.
 * @param msg  Pointer to the input/output message buffer.
 *
 * @return 0 on success, -1 on failure.
 *
 * @note The ID is generated by incrementing the database's internal `core->id` counter.
 *
 * @warning If insertion into the KV store fails after the vector was inserted, the vector 
 *          is rolled back and an error is returned.
 *
 * @warning The function performs dynamic memory allocations for vector and value, which
 *          are freed before return.
 */
static int handle_add_message(IndexKV *core, buffer_t *msg) {
    float32_t *vector = NULL;
    uint8_t   *value  = NULL;
    uint64_t  id;
    size_t dims = 0;
    size_t vlen = 0;
    int code;
    int ret;
    int vret;

    ret = buffer_read_add(msg, &vector, &dims, &value, &vlen); 
    if (ret == -1) {
        log_message(LOG_ERROR, "parsing add message");
        return -1;
    }

    id = ++(core->id);

    if ((code = insert(core->index, id, vector, dims)) != SUCCESS) {
        if (code == SYSTEM_ERROR)
            log_message(LOG_ERROR, 
                "at vector insert - code: %d - message: %s", 
                code, index_strerror(code)
            );
        else
            log_message(LOG_WARNING, 
                "at vector insert - code: %d - message: %s", 
                code, index_strerror(code)
            );
        ret = buffer_write_error(msg, code, index_strerror(code));
        goto cleanup;
    }

    if ((code = kv_put(core->table, &id, 8, value, vlen)) != KV_SUCCESS) {
        log_message(LOG_ERROR, 
            "at value insert - code: %d - message: %s",
            code, "unknown"
        );
        vret = delete(core->index, id);
        if (vret != SUCCESS)
            log_message(LOG_ERROR, 
                "rollback (delete) on insert error - code: %d - message: %s",
                vret, index_strerror(vret)
            );
        ret = buffer_write_error(msg, code, index_strerror(code));
        goto cleanup;
    }

    core->op_add_counter++;
    ret = buffer_write_add_result(msg, id);

cleanup:
    if (vector) free(vector);
    if (value)  free(value);
    return ret;
}

/**
 * @brief Handles a lookup (nearest neighbor search) message.
 *
 * This function processes an incoming `MSG_LOOKUP` message, extracts the query vector,
 * performs a nearest neighbor search against the configured index, fetches the associated
 * values from the key-value store, and writes the results back to the buffer.
 *
 * Workflow:
 * 1. Parse the message and extract the query vector(s) via `buffer_read_lookup()`.
 * 2. Execute `search_n()` on the index with the specified number of matches.
 * 3. For each match, retrieve the corresponding value from the KV store.
 * 4. Write the lookup result back using `buffer_write_lookup_result()`.
 * 5. On any error, write an error message with `buffer_write_error()` and return -1.
 *
 * @param core Pointer to the database structure.
 * @param msg  Pointer to the input/output buffer containing the message.
 *
 * @return 0 on success, -1 on failure.
 *
 * @note If a matched key is not found in the KV store, a warning is logged but the 
 *       process continues with the rest of the results.
 *
 * @note The function dynamically allocates memory for the result array and
 *       associated values, which are freed before returning.
 *
 * @warning If memory allocation fails, the function sends a 500 error response
 *          to the client.
 */
static int handle_lookup_message(IndexKV *core, buffer_t *msg) {
    uint64_t *ids    = NULL;
    uint8_t **values = NULL;
    size_t *vlen     = NULL;

    MatchResult *result = NULL;
    float32_t *vector   = NULL;
    size_t dims;
    int ret, n;

    ret = buffer_read_lookup(msg, &vector, &dims, &n);
    if (ret == -1) {
        log_message(LOG_ERROR, "parsing lookup message");
        return -1;
    }

    result = calloc(n, sizeof(MatchResult));
    if (!result) {
        ret = buffer_write_error(msg, 500, "database out of memory");
        goto cleanup;
    }

    ret = search_n(core->index, vector, (uint16_t)dims, result, n);
    if (ret == SUCCESS) {
        int i = 0;
        if ((ids    = calloc(n, sizeof(uint64_t))) == NULL || 
            (vlen   = calloc(n, sizeof(size_t)))   == NULL ||
            (values = calloc(n, sizeof(uint8_t *))) == NULL) {
            log_message(LOG_ERROR, 
                "system error: %d - message: %s",
                errno, strerror(errno)
            );
            ret = buffer_write_error(msg, 500, "database out of memory");
            goto cleanup;
        }
        while ( i < n ) {
            ids[i] = result[i].id;
            if (kv_get(core->table, &ids[i], 8,(void **)&values[i], (int *)&vlen[i]) != KV_SUCCESS) {
                log_message(LOG_WARNING, "value not found %llu", (unsigned long long)ids[i]);
                values[i] = NULL;
                vlen[i] = 0;
            }
            i = i + 1;
        }
        ret = buffer_write_lookup_result(msg,
                ids, (const uint8_t **) values, vlen, i);
    } else 
        ret = buffer_write_error(msg, ret, index_strerror(ret));

cleanup:
    if (vector) free(vector);
    if (result) free(result);
    if (ids)    free(ids);
    if (vlen)   free(vlen);
    if (values) free(values);
    return ret;
}


/**
 * @brief Loads and applies WAL operations to the IndexKV database.
 *
 * This function reads and replays all operations stored in a Write-Ahead Log (WAL) file.
 * Each message is parsed and executed according to its type (e.g., `MSG_ADD`, `MSG_DEL`).
 * It ensures database state restoration after a crash or restart.
 *
 * @param core Pointer to the IndexKV database structure to apply the WAL to.
 * @param wal  FILE* pointer to an already opened WAL file in binary read mode.
 *
 * @return 
 *   0 on successful import of all WAL entries,  
 *  -1 on failure due to I/O error or corrupted WAL content.
 *
 * @note 
 *   If the WAL contains unknown message types, they will be skipped with a warning.
 *   If an error occurs and `errno` is 0, it is assumed the WAL is corrupted.
 *   If `errno` is non-zero, a system-level I/O error is assumed.
 */
int indexkv_load_wal(IndexKV *core, FILE *wal) {
    buffer_t *buff = alloc_buffer();
    int ret;

    if (!buff) {
        log_message(LOG_ERROR, "failed to allocate buffer");
        return -1;
    }

    while ((ret = buffer_load_wal(buff, wal)) == 1) {
        switch (buff->hdr.type) {
            case MSG_ADD:
                handle_add_message(core, buff);
                break;
            case MSG_DEL:
                handle_del_message(core, buff);
                break;
            default:
                log_message(LOG_WARNING,
                    "unknown message type in WAL: %d", buff->hdr.type);
                break;
        }
    }

    free(buff);

    if (ret == 0) {
        log_message(LOG_INFO, "WAL imported successfully");
        return 0;
    }

    if (errno == 0)
        log_message(LOG_ERROR, "WAL corruption detected during import");
    else
        log_message(LOG_ERROR, "I/O error during WAL import: %s", strerror(errno));

    return -1;
}


/**
 * @brief Starts the IndexKV server loop, handling client requests and writing to WAL.
 *
 * This function implements the main server loop for the IndexKV database. It accepts
 * incoming UNIX domain socket connections, processes protocol messages from clients,
 * and writes changes to a Write-Ahead Log (WAL) file for durability.
 *
 * Supported message types:
 * - `MSG_ADD`: Adds a new vector to the database and appends to the WAL.
 * - `MSG_DEL`: Removes a vector and appends to the WAL.
 * - `MSG_LOOKUP`: Performs a vector search (no WAL entry).
 *
 * The server uses `select()` to multiplex connections and listens until a termination
 * signal is received (`running == 0`), at which point it gracefully shuts down.
 *
 * @param core Pointer to the database structure.
 * @param server File descriptor of a bound and listening UNIX socket.
 *
 * @return 0 on clean shutdown, -1 on failure (e.g., memory, I/O, or socket error).
 *
 * @note The WAL file is opened in append mode. If it cannot be opened, the server
 *       fails to start. The server respects signals via the global `running` flag.
 *
 * @warning Only `MSG_ADD` and `MSG_DEL` are persisted in the WAL.
 * @warning Maximum number of simultaneous connections is limited by `MAX_CONNECTIONS`.
 * @warning If `recv_msg` or `send_msg` fail, the client connection is closed.
 */
int indexkv_server(IndexKV *core, int server) {
    FILE *wal = NULL;
    int conn[MAX_CONNECTIONS];
    fd_set set, check;
    int max = server, n;
    buffer_t *buff = alloc_buffer();
    
    if (!buff) {
        log_message(LOG_ERROR, 
            "failed to allocate buffer"
        );
        close(server);
        return -1;
    }

    wal = fopen(WAL_FILE, "ab");
    if (!wal) { 
        log_message(LOG_ERROR, 
            "failed to open WAL file '%s': %s", 
            WAL_FILE, 
            strerror(errno)
        );
        free(buff);
        close(server);
        return -1;
    }
    for (int i=0; i < MAX_CONNECTIONS; i++) conn[i] = -1;

    FD_ZERO(&set);
    FD_ZERO(&check);
    FD_SET(server, &set);

    while (running) {
        memcpy(&check, &set, sizeof(fd_set));
        n = select(max+1, &check, NULL, NULL, NULL);
        if (n < 0 && (errno == EAGAIN || errno == EINTR))
            continue;
        else if (n < 0) {
            log_message(LOG_ERROR, 
                "fatal error on select (%d) - %s",
                errno, strerror(errno)
            );
            break;
        }
        if (FD_ISSET(server, &check)) {
            int i;
            int sd = unix_accept(server);
            if (sd == -1)
                if (errno != EAGAIN && errno != EINTR) {
                    log_message(LOG_ERROR, 
                        "fatal error on unix_accept (%d) - %s",
                        errno, strerror(errno)
                    );
                    break;
                }
            for (i = 0; i < MAX_CONNECTIONS; i++)
                if (conn[i] == -1) {
                    conn[i] = sd;
                    break;
                }
            if (i == MAX_CONNECTIONS) {
                log_message(LOG_WARNING,
                    "max conections reached - new client closed"
                );
                close(sd);
            } else {
                max = sd > max ? sd : max;
                FD_SET(sd, &set);
            }
            n--;
        }

        for (int i = 0; i < MAX_CONNECTIONS && n > 0; i++) {
            int ret = 0;
            if (FD_ISSET(conn[i], &check)) {
                n--;
                ret = recv_msg(conn[i], buff);
                if (ret == -1) {
                    log_message(LOG_WARNING,
                        "connection closed due to protocol or receive error"
                    );
                    FD_CLR(conn[i], &set);
                    close(conn[i]);
                    conn[i] = -1;
                    continue;
                }
                switch (buff->hdr.type) {
                case MSG_ADD:
                    if (buffer_dump_wal(buff, wal) != 0)
                        log_message(LOG_WARNING,
                            "writing wal (%s) - message: %s",
                            errno, strerror(errno)
                        );
                    ret = handle_add_message(core, buff);
                    break;
                case MSG_DEL:
                    if (buffer_dump_wal(buff, wal) != 0)
                        log_message(LOG_WARNING,
                            "writing wal (%s) - message: %s",
                            errno, strerror(errno)
                        );
                    ret = handle_del_message(core, buff);
                    break;
                case MSG_LOOKUP:
                    ret = handle_lookup_message(core, buff);
                    break;
                default:
                    log_message(LOG_WARNING,
                        "invalid protocol message type: %d",
                        buff->hdr.type
                    );
                    ret = -1;
                }
                if (ret != -1) {
                    if (send_msg(conn[i], buff) == -1) {
                        FD_CLR(conn[i], &set);
                        close(conn[i]);
                        conn[i] = -1;
                    }
                } else {
                    FD_CLR(conn[i], &set);
                    close(conn[i]);
                    conn[i] = -1;
                }
            }
        }
        if (core->op_add_counter + core->op_del_counter > EXPORT_THRESHOLD) {
            // TODO: Dump all data if threshold exceeded
        }
    }
    log_message(LOG_INFO, "end main loop");
    fclose(wal);
    free(buff);
    for (int i = 0; i < MAX_CONNECTIONS; i ++)
        if (conn[i] != -1)
            close(conn[i]);
    close(server);
    return 0;
}